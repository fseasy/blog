---
layout: mathpage
title: C++Primer读书笔记15
date: 2016-06-22
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第十五章 - 面向对象程序设计。
---
> C++ Primer（第五版）第十五章 - 面向对象程序设计。

1. OOP

    Object-Oriented Programing

2. OOP核心思想

    **数据抽象**，**继承**，**动态绑定**。

    数据抽象：将类的接口与实现分离

    继承： 定义相似类型并对相似关系建模

    动态绑定（多态）： 在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。

3. 基类与派生类的存储

    派生类包含基类的部分。所以可以隐式的将派生类转为基类（或许应该加限制，通过引用或指针的形式）。

    所以，派生类的构造函数需要先构造基类部分，再构造派生类独有的部分。派生类析构时，先析构自己独有的，再析构基类。

    派生类只能通过基类的构造函数来啊初始化基类数据成员。同理，只应该让基类的析构函数去析构基类的成员。

4. 基类在被继承前必须已经声明完成。

    即，不完整类型不能用作基类。这隐式地说，一个类不能自身继承自身。

5. 静态类型与动态类型

    静态类型就是在编译时已知的类型，它是变量声明时的类型或者表达式生成的类型。

    动态类型是变量或表达式表示的内存中的对象的类型。动态类型只有在运行时才能确定。

    动态类型与静态类型不一致，当且仅当通过指向基类的指针或引用来调用虚函数时才有可能发生。即发生动态绑定时，动态类型与静态类型可能不一致。

6. 继承类与基类的转换

    不存在基类想继承类的转换，因为基类只是是继承类的一部分。

    不存在继承类对象向基类对象的转换。只有通过引用或者指针的形式！

7. 何时才可能发生动态绑定

    只有通过指针或者引用调用虚函数时，才会在运行时解析该调用。

    故以下两种不可能发生动态绑定——

    1. 通过对象调用虚函数。

    2. 通过引用或指针调用非虚函数。

8. 针对虚函数的`final`修饰符与`override`修饰符

    第一，finial和override修饰符只针对虚函数！

        // clang 的报错
        error: only virtual member functions can be marked 'final'
        error: only virtual member functions can be marked 'override'

    一个虚函数定义为final后，继承类就再也不能重写它了。

    一个虚函数在继承类中被用override修饰，是为了让编译器帮助检查我们**是否真的覆盖**了这个虚函数，而不是仅仅定义了一个同名的函数（隐藏了父类的虚函数）。

        ‘void DS::print() const’ marked override, but does not override

    final与override之间没有顺序关系，但是二者都必须放在其他函数修饰符之后（const，引用修饰符？）。

        virtual void print() const final override ;

    最后，final、override是声明修饰符，定义时不能出现!

9. 含有纯虚函数的类（抽象类）不能实例化对象

    即使这个纯虚函数在外部有定义，还是不能实例化。

    一般来说，抽象类是用于定义接口的，不是用于实例化的。
