---
layout: mathpage
title: C++Primer读书笔记15
date: 2016-07-17
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第十五章 - 面向对象程序设计。
---
> C++ Primer（第五版）第十五章 - 面向对象程序设计。

1. OOP

    Object-Oriented Programing

2. OOP核心思想

    **数据抽象**，**继承**，**动态绑定**。

    数据抽象：将类的接口与实现分离

    继承： 定义相似类型并对相似关系建模

    动态绑定（多态）： 在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。

3. 基类与派生类的存储

    派生类包含基类的部分。所以可以隐式的将派生类转为基类（或许应该加限制，通过引用或指针的形式）。

    所以，派生类的构造函数需要先构造基类部分，再构造派生类独有的部分。派生类析构时，先析构自己独有的，再析构基类。

    派生类只能通过基类的构造函数来啊初始化基类数据成员。同理，只应该让基类的析构函数去析构基类的成员。

4. 基类在被继承前必须已经声明完成。

    即，不完整类型不能用作基类。这隐式地说，一个类不能自身继承自身。

5. 静态类型与动态类型

    静态类型就是在编译时已知的类型，它是变量声明时的类型或者表达式生成的类型。

    动态类型是变量或表达式表示的内存中的对象的类型。动态类型只有在运行时才能确定。

    动态类型与静态类型不一致，当且仅当通过指向基类的指针或引用来调用虚函数时才有可能发生。即发生动态绑定时，动态类型与静态类型可能不一致。

6. 继承类与基类的转换

    不存在基类想继承类的转换，因为基类只是是继承类的一部分。

    不存在继承类对象向基类对象的转换。只有通过引用或者指针的形式！

7. 何时才可能发生动态绑定

    只有通过指针或者引用调用虚函数时，才会在运行时解析该调用。

    故以下两种不可能发生动态绑定——

    1. 通过对象调用虚函数。

    2. 通过引用或指针调用非虚函数。

8. 针对虚函数的`final`修饰符与`override`修饰符

    第一，finial和override修饰符只针对虚函数！

        // clang 的报错
        error: only virtual member functions can be marked 'final'
        error: only virtual member functions can be marked 'override'

    一个虚函数定义为final后，继承类就再也不能重写它了。

    一个虚函数在继承类中被用override修饰，是为了让编译器帮助检查我们**是否真的覆盖**了这个虚函数，而不是仅仅定义了一个同名的函数（隐藏了父类的虚函数）。

        ‘void DS::print() const’ marked override, but does not override

    final与override之间没有顺序关系，但是二者都必须放在其他函数修饰符之后（const，引用修饰符？）。

        virtual void print() const final override ;

    最后，final、override是声明修饰符，定义时不能出现!

9. 含有纯虚函数的类（抽象类）不能实例化对象

    即使这个纯虚函数在外部有定义，还是不能实例化。

    一般来说，抽象类是用于定义接口的，不是用于实例化的。

10. 派生类列表中的访问控制符只影响后续的派生类及类的使用者

    就是这样一种情况：

        class Derived : [public/protect/private] Base
        {}

    然后首先说明三种用户：

    1. 类自身（自身成员） + 友元

    2. 类的继承者们

    3. 类的使用者

    然后，在派生类表的限制访问符，对用户1，即类自身是毫无影响的！在Derived内部，能否访问Base的成员，完全取决于Base中成员的可访问性。但是，对于类的继承者和类的使用者，对于基类成员的访问就受到了该控制符的影响。具体的就是继承者只能访问protected以上，外部只能使用public。

11. 派生类向基类的转换

    这里似乎仍然与上面相同。对于类自身，均可转换；对于继承者，只有protected以上；用户代码只能public。

    看下面的代码：

        // 定义基类，以及3个不同访问权限的派生类
        class Base
        {
            int a = 10;
        };

        class Pub_D : public Base
        {};

        class Prot_D : protected Base
        {
            public:
            void set(Base &b){ b = *this; }
        };

        class Priv_D : private Base
        {
            
        };

        // 测试转换访问权限
        int main(int argc , char *argv[])
        {
            Pub_D pubd;
            Prot_D protd;
            Priv_D privd;
            Base &b = pubd; // OK
            protd.set(b); // OK , 在类内部转换

            Base *pb = &pubd; // OK ， public的
            pb = &prot; // Error， 外部不可访问
            pb = &privd; // Error，外部不可访问
            return 0;
        }



12. 对基类的友元 对基类成员的访问由基类本身决定

    尽管我们知道友元关系是不可继承的，但是基类的友元对于派生类中基类成员的访问仍然是完全可行的。

    即，尽管基类的友元与派生类没有关系，但是还是可以访问派生类中基类的部分！

    这个看起来有些奇怪，不过这也说明了一点：派生类中基类的部分真的是完全分开的！尽管是融合在一起了，但是访问权限依然还在。所以，可以认为派生类就是在内部有个到基类的指针。然后派生类自己可以任意控制指针的访问权限，但是外部类要访问基类就需要过这个权限限制了。然后派生类与基类的本身的成员是相互独立的，权限各自独立。