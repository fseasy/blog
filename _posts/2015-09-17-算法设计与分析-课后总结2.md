---
layout: mathpage
title: 算法设计与分析-课后总结2
date: 2015-09-17
categories: 笔记
tags: 算法
onewords: 第二节课主要讲数学基础。
---
> 数学基础，包含渐进符号含义（用于算法复杂度表示），递归方程（由递归方程求解算法复杂度）。

###渐进符号

1. $\Theta$

    同阶函数集。

    $f(n) = \Theta(g(n))$表示在$c_1g(n)$ 与 $c_2g(n)$中函数集合，且这些函数满足：$c_1$,$c_2$是存在的，且存在$n_0$，使得$ n \ge n_0$时恒有$c_1g(n) \le f(n) \le c_2g(n)$ 。我们将其记为$f(n) = \Theta(g(n))$ 。 即$f(n)$是$g(n)$的同阶函数。 

    > 上面的表示是书上的表示，我觉得并没有什么用。

    用后面的的知识，我们可以认为，如果是同阶函数，则当n趋于正无穷时，两函数比值的极限为常数. 即 

    $$ \lim_{n \to infty}\frac{f(n)}{g(n)} = c $$ , $c$是一个常数。

    **考试中可能出题要求证明，两个函数是同阶函数**

    - 使用定义来证明，即对$c_1g(n) < f(n) < c_2g(n)$ , 找到合适的$c_1$ , $c_2$ ，找到临界点或者正确的点$n_0$即可。

    定理（待证明） ： **对任意多项式$p(n) = \sum_{i=0}^{d}{a_in^i}$ , 其中$a_i$是常数且$a_d$为正常数，则有$p(n) = \Theta(n^d)$**。直观来看，就是对于多项式函数，其同阶函数就是该变量的最高次项（忽略非最高次项，忽略最高次项的系数）。

    $\Theta$符号定义了函数的上下确界。

2. $O$

    低阶函数集。

    $f(n) = O(g(n)) (f(n) \le cg(n))$定义了以$cg(n)$为上界的函数集。（当然是有条件的，即$c$大于0 ， $g(n)$非负）

    同阶函数也可以用大O表示(取等号时)。

3. $\Omega$

    高阶函数集。
    
    $f(n) = \Omega (g(n)) ( f(n) \ge cg(n)) $ 定义了以$c g(n) $为下界的函数集。

    同样包含同阶函数。可以认为$O$与$\Omega$互逆。

4. $o$
    
    与$O$类似，但定义的是严格低阶函数（不取等号，但是在算法导论中，不是如此定义的）。

    算法导论中定义，对任意的$c$ , 存在常数$n_0 > 0$ ， 使得$n > n_0$时有 $ 0 \lt f(n) \le cg(n)$ . 不知道这里取等号究竟是疏漏还是确实如此。但这个从直观上理解更好确定。就是一个严格低阶的函数集。

5. $\omega$

    严格高阶的函数集。

6. 条件补充

    上面的集合、函数定义条件都没有说完整。这里把他的上下文说完整。

    **首先需要明确，不是任何两个函数都有渐近关系，都能用渐近符号表示的。**算法导论上举了线性函数$n$ 与函数 $n^{1 + \sin{n}}$。由于前者随n增大线性变化，而后者由于指数在0到2间随n循环变化，值域变化太大。二者存在渐近关系。

    其次，这里的函数，$f(n)$ ， $g(n)$ 都是非负的。因为这些都是由实际意义的函数（算法复杂性表示）。$c_*$也是正数。

7. 渐近关系的一些性质

    1. 传递性 （类似 $f(n) = O(g(n)) $ , $ g(n) = O(k(n)) $ ，则有 $ f(n) = O(k(n)) $ 等）

    2. 自反性 $f(n) = \Theta(f(n))$ , $f(n) = O(f(n))$ , $f(n) = \Omega(f(n))$

    3. 对称性 只同阶函数，即$f(n) = \Theta (g(n)) iff g(n) = \Theta (f(n))$

    4. 转置对称性 指$O$与$\Omega$ , $o$ 与$\omega$之间的对称。如$f(n) = O(g(n)) iff g(n) = \Omega(f(n))$
 

### 递归方程

递归式(recurrence) : 当一个算法包含对自身的递归调用时，其运行时间通常可以用递归式来表示。

课程（书籍）主要介绍了三种递归式求解方法，分别是`代换法`(substitution method) , `递归树方法`（recursion-tree）(或者称为循环展开方法，iteration method) ， `主方法`（Master Method ， 课程中称为Master定理） 。 

在求解递归式时，通常需要略去一些技术细节。例如 *上取整* , *下取整* , *边界条件*。

如实际的MERGE-SORT的运行时间递归式应该为：

$$
T(n) = \begin{cases}
\Theta(1) & n = 1 \\
T(\lceil \frac{n}{2} \rceil) + T(\lfloor \frac{n}{2} \rfloor) + \Theta(n) & n \gt 1 
\end{cases}
$$

忽略细节的条件下，可以写作：

$$ T(n) = 2 T(\frac{n}{2}) +\Theta(n) $$

以下将分别介绍3种求解方法。

1. 代换法(substitution)

    这里的代换法，不仅仅是字面上的替换之意，一般包含两个步骤：

    1. 猜测可能的时间复杂度（或者上下界）

    2. 使用数学归纳法进行证明

    所以这个主要是针对一些常见形式的递归方程。当然，对于不能直接猜测的方程，我们可以先使用第二种方法——递归树方法粗略的猜测一个结果，然后使用该方法来得到确切的证明。

    **一个例子：**

    $T(n) = 2T(\frac{n}{2}) + n$

    这个式子比较熟悉了，就是归并排序的递归式，我们猜测其时间复杂度为$O(n \lg n)$ , 即 $ T(n) = O(n \lg n)$

    *接下来就需要使用数学归纳法来证明该递归式的时间复杂度的确是$O(n \lg n)$*

    **按照数学归纳法的一般步骤，首先要证明 初始条件（在算法中称为`边界条件`，此后主要使用该称呼）需要得到满足**

    1. 证边界条件

        按照常理来说，边界条件为 ： $n = 1$时，满足 $ T(1) \le c \cdot n \lg n = c \cdot 1 \cdot \lg 1 = 0 $

        我们知道$T(1)$是不可能小于等于0的（一般取1），**故这里证明边界条件就出现了问题！**

        是否是我们的猜想不对呢？

        **这里我们需要回到渐近符号的定义： 对任意渐近符号，满足不等式的条件都是对$n \gt n_0 , n_0 > 0$这一前提条件来说的，所以说，我们的边界条件不是 $n = 1$ ， 而是$n=n_0$ ，这里我们可以取$n_0 = 2$** 

        $T(2) = 2T(1) + 2 = 2 + 2 = 4 \le 2\lg 2 \cdot c$ , c取大于2的数时即满足条件。

        故边界条件得证。

    2. 证递推成立

        假设$T(n) = O(n \lg n)$成立，即有$T(n) <= c \cdot n \lg n , c \gt 0$

        下一个递推项为$2n$(这里注意，根据递归方程，下一项我们取$2n$ ，而不是以前数学中常取的$n+1$)

        只需证明 $ T(2n) <= c \cdot 2n \lg (2n) = 2c n\lg n + 2 \lg2 \cdot c n $即可。

        $$\begin{align*}
        T(2n) &= 2T(n) + 2n \\
              &\le 2 \cdot ( c \cdot n \lg n ) + 2n \\
              &= 2 \cdot n \lg n + 2n \\  
        \end{align*}$$

        要使$ 2 c n \lg n + 2 n \le 2 n \lg n + 2 \lg2 c n $

        只需$ \lg2 c \ge 1 $ 即可 ， 即取$ c \ge \frac{1}{\lg2}  $

    证毕。

    从上面的例子可以看出，在算法问题中使用数学归纳法与传统高中数学使用的数学归纳法还是有所差别的，但是，这并不是说，在算法中使用数学归纳法就不足够严谨。在上例中，改变边界条件、确定下一个递推项，都是根据实际情况做出的判断，而不是纯粹的数学推理。在实际问题中应用数学，即要保证符合实际情况，又要符合数学的严谨，这实在是很难的一个过程。

    **猜测的例子**

    对于递归式 $ T(n) = 2T(\lfloor \frac{n}{2} \rfloor + 17) + n $ , 求其复杂度。

    我们要知道，渐近符号一般都是在变量趋于无穷大时才有渐近意义。故而，在该例子中，当n趋于无穷大事，$\lfloor \frac{n}{2} \rfloor + 17$ 完全可以等价于 $ \lfloor \frac{n}{2} \rfloor$ ，经过如此等价，递归式又与MERGE-SORT的递归式一致了。从而，我们给出猜测$O(n\lg n)$ ， 然后再运用数学归纳法证明（当然，在证明中其实也需要用到该约等于条件。在趋于无穷大时，该条件能够保证其严谨性）。

