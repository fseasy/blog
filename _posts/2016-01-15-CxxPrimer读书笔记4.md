---
layout: mathpage
title: C++Primer读书笔记4
date: 2016-01-15
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords:  第七章-类。
---
> C++ Primer（第五版）第七章内容——类。

*注意：定义类之后，需要一个分号！！*

0. 定义类的目的

    数据抽象与封装。

    对外指提供接口，隐藏实现。或者说接口与实现分离。

1. 类成员函数声明与定义

    类的成员函数都要声明在类内部，但定义可以外部。

    定义在内部的成员函数默认是内联(inline)的(隐式inline)。

2. 类成员函数的隐式this指针

    在成员函数内部访问类成员或函数，都隐式的通过`this`指针访问。

        string Info::get_info()
        {
            return info ; 
        }
        
        Info inf ;
        cout << inf.get_info() ;
        
        ==>

        string Info::get_info(Info * const this )
        {
            return this->info
        }
        Info inf ;
        cout << get_info(&inf) ;

    如上，就大概是编译器实际实现类成员函数调用、访问的过程。这个通过Python中类成员函数定义就比较清晰。

        Class Info(object) :
            def get_info(self) :
                return self.info


    需要注意的是其中的`const`，根据书上的描述，`this`的值是不能被改变的。所以我想它传递的应该是一个底层const的指针。

    > 因为this变量被隐式定义，所以我们不能再定义名为this的变量。也不能修改this变量的值。


3. 定义const成员函数

    如果成员函数不修改成员变量值，那么通过在函数形参列表后加入const关键字来实现该逻辑。

        string Info::get_info() const {...}

    实际上是通过给隐式的`this`指针加上顶层`const`。

        string Info::get_info(const Info *const this) {...}

    如果类要支持常量定义，那么定义const的函数是必须的。因为如果定义类的const实例，而函数都是非const的，由于非const实例不能绑定到顶层const指针上，所以成员函数不可用。

4. 类作用域

    类本身就是一个作用域。

    在外部定义类的成员函数时，需要使用作用域运算符`::`。
        string Info::get_info()
        {
            return info .
        }

5. 类成员变量、成员函数的定义顺序与调用顺序无关

    如果函数A定义在函数B的后面，但是在函数B也可以直接调用函数A。

    因为编译器分两步处理类：

    首先编译成员的声明。

    然后再编译函数体（如果有的话）。

6. 返回调用对象本身的引用

    使用`*this`来返回调用的对象本身。

        Info& Info::add(Info & b) 
        {
            info += b.info ;
            return *this ;
        } 
    
    注意函数返回类型的引用符号——返回的是调用对象的引用，即左值。

7. 类的拷贝

    IO类不能拷贝。只能传引用。

    默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。

8. 默认构造函数

    当类中没有定义任何构造函数时，编译器尝试创建一个默认构造函数，也叫 合成的默认构造函数(synthesized default constructor)。

    有3点：

    1. 如果自定义了构造函数，则默认构造函数不会被创建。

        不过可以快捷的定义一个默认的构造函数。

            Info::Info() = default ;

        对，就是这么定义。

    2. 默认构造函数，编译器对成员变量执行初始化的流程：

        - 如果指定了默认值，用默认值初始化。

        - 没有，则尝试用默认值初始化该成员变量。

    3. 由上，引出了默认构造函数可能导致的问题:

        - 对内置类型的成员变量，因为成员变量属于块内变量（局部变量），故执行随机初始化。

        - 如果成员变量类型是另外一个类类型，且该类型没有默认构造函数，那就报错了。


9. 构造函数的初始值列表

    在参数列表后、函数体前（左大括号前）使用`:member_var(param_var),...`来定义初始值列表。

        Sales_data(string &s , unsigned n , double p):
                   bookNo(s) , revenue(p*n)} {}

10. **总结初始化顺序**

    1. 初始化列表
    2. 函数体
    3. 如果上述两步操作中还有未涉及的成员变量，则对这些成员变量：

        1. 如果有默认值（`类内初始值`，即在声明成员变量时定义的值），则用该值初始化
        2. 否则，执行`默认初始化`

        所谓默认初始化，即是说：

        1. 如果变量是内置类型

            1. 如果是全局变量（任何函数外），则初始为0（0，0.0 , nullptr,false等，根据具体类型定）
            2. 否则为局部变量，不初始化（即随机值，根据那块内存的原始值）

        2. 如果变量是类类型（STL或者用户自定义）

            1.尝试调用无参构造函数

            2. 失败则报错

        还是有些复杂的。

        不过具体到类上面，因为不可能是全局变量，所以此时的默认初始化只可能有两种：

        1. 内置类型不初始化

        2. 类类型使用无参构造函数初始化 

    验证代码：

        struct Other
        {
            Other()
            {
                o = 100 ;
            }
            int o ;
        } ;

        class Test 
        {

            public :
                Test() = default ;
                Test(int a , string  b ): 
                a(a) , b(b) 
                {
                    this->b = "stupid initialization method for reapeating" ; 
                };
                void print()
                {
                    cout << " a " << a << endl
                         << " b " << b << endl 
                         << " c " << c << endl 
                         << " d " << d << endl 
                         << " o " << o.o << endl ;
                }
            private :
                int a = 5 ;
                string b = "info" ;
                double c ;
                string d ;
                Other o ;

        } ;


        int main(int argc ,  char *argv[] )
        {
            Test t ;
            t.print() ;
            
            Test tt(2,"changed") ;
            tt.print() ;

            return 0 ;
        }

    输出结果：

         a 5
         b info
         c 3.11217e-317
         d 
         o 100
         a 2
         b stupid initialization method for reapeating
         c 9.88131e-324
         d 
         o 100

11. 类的拷贝、赋值和析构

    这里讲的应该仍然是基础。

    类对象间的`=`操作会发生赋值（拷贝），对象生命结束会发生析构。

    如果我们未定义自己的赋值（拷贝）、析构操作，那么编译器将自动**合成**这种操作！

    编译器的行为是：对类对象的**每个成员**，做赋值（拷贝）、析构操作。

    所以，如果类中的成员，除了类对象本身的空间外，没有额外的空间占用（我的理解，就是指针！如果有new操作，那么显然类本身只有指针本身的大小，但是在类空间之外，还有由指针指向的*堆空间*），那么编译器默认的操作就是没有危险的。赋值（拷贝）不会有遗漏，析构不会漏掉内存泄露。

    如果有动态内存操作，那么必须要手动管理这些操作！（应该在后续介绍，目前所知，对于析构就是定义析构函数了）

    > 使用vector完全没有问题！ 因为vector本身有完善的赋值（拷贝）、析构操作，不会有内存问题。vector在赋值时（`=` , push_back`等操作），会拷贝元素值！在析构时，会清空vevtor装的所有元素值！

    > 使用vector时就可以直接用默认的操作，这告诉我们封装的好处。即，自己的事情自己做，外部只需要告诉你命令。

12. 访问控制与封装

    主要说一下`public`和`private`的依据：

    `public` 下的成员应该是要提供给外部的接口。

    `private` 下的内容应该是被隐藏的细节。

    以上就实现了封装！

13. 关键字`class`与`struct`的区别

    **在C++中，`class`和`struct`都是定义的类类型！他们唯一的区别就是——默认的访问权限**。

    `class`是`private` ， `struct`是`public`。

    不要受C的影响。

14. 友元

    友元定义的方法：

    1. 在类内部声明友元函数，使用`friend`关键字 [作为类的友元的声明]

    2. 在类声明所在的头文件中声明友元函数。[作为函数的声明] （经过测试，在GCC下可省略。）

    建议：

    友元声明在类的开始或者结束

    性质：

    友元函数不属于类的成员，不受所在位置的访问控制级别约束。

    友元函数可以访问类的非公有成员。

    写的一个例子：

        ------
        test.h

        class People
        {
            // friend function declaration
            friend void teach_knowledge(std::string , People &) ;

            public :
                void make_self_introduction() ;
            private :
                std::string knowledge ;
        } ;

        // function declaration
        void teach_knowledge(std::string , People &) ; 

        --------
        test.cpp(调用部分)

        int main(int argc ,  char *argv[] )
        {
            People p ;
            teach_knowledge("my name is xuwei" , p ) ;
            teach_knowledge("I am 5 years old " , p ) ;
            p.make_self_introduction() ;
            return 0 ;
        }

15. 在类中定义一个类型成员

    即是，在类作用域下，定义一个类型成员。

    如书上的例子：

        class Screen
        {
        public :
            typdedef std::string::size_type pos  ;
            
            //using pos = std::string::size_type 
        }

    在类中定义的类型，作用域在类中，且受到访问控制的约束！即上述定义的类型pos是public的，可以在外部被访问。

    与其他类成员不同，类型必须先定义，才能使用。所以应该定义在类的开始。

16. 令成员成为内联函数

    前面说到，如果在类内部声明并定义，那么这个函数是隐式内联的。

    也可以使用`inline`显式内联。此时，可以在声明位置或定义位置使用`inline`表示，也可以在两个位置都写上`inline`.

    书上说声明为内联的函数应该声明和定义在同一个（头）文件中；不过在GCC中，不在一个文件中也没有问题。

17. **可变数据成员**

    使用`mutable`关键字来定义可变数据成员。

    看到的应用场景是：如果一个成员函数定义为`const`的，那么理论上它不能修改任何成员变量。但是如果一个变量使用`mutable`修饰，那么这个成员就可以被const函数修改。可以用来统计类的操作被调用次数。

    例：
        mutable size_t access_ctr ;

18. 类数据成员的初始化

    在C++11的新标准中，建议使用`类内初始值`的方式。即，直接使用`=`或`{}`赋初值。

19. 返回一个`*this`对象引用

    如果想要支持链式处理，那么就有必要返回一个`*this`的对象引用！

    注意的一点是，一个返回*\*this*引用的成员函数，如果对象被定义const的。那么这个函数就不能够被调用了！因为对象为const时，传入的this指针是const的，然而返回时却要求返回非const的对象，我们知道可以将非const隐式转为const的，但是const的转为非const的，需要使用`const_cast`。