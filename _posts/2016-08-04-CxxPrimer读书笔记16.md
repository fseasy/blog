---
layout: mathpage
title: C++Primer读书笔记16
date: 2016-08-04
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第十六章 - 模板与泛型编程。
---
> C++ Primer（第五版）第十六章 - 模板与泛型编程。

1. 泛型与OOP
    
    泛型与OOP都能处理在编写程序时不清楚具体类型的情况。

    OOP是通过继承+动态绑定；而泛型则是通过编写类型独立的代码，并且在编译时实例化模板完成。

2. 泛型编程的基础是模板。模板可以解释为一个创建类或函数的蓝图或公式。

    单纯的模板名不是类！

3. 模板参数列表

    模板参数列表可以类比函数参数列表。函数参数（形参）在调用时初始化，而模板参数在实例化模板时显示或隐式指定。

    1. 通过`template<XXX>`来指定模板参数列表。模板参数列表在定义模板时必须不为空。

    2. 模板参数有两类，一类是`模板类型参数`，通过 `typename`或者`class`指定（二者完全等价，class是在typename没有出来前所使用的名称），通过此参数可以定义**类型**；另一类称为`非类型模板参数`，即通过`常规类型 + 名称`指定，定义的是值。

        综上，**模板参数列表可以定义类型、也可以定义值**。如下：

            template<typename T, size_t N>
            constexpr size_t size(const T (&a)[N])
            {
                return N;
            }
    3. 传递给模板参数列表中的值，要么是**整型字面值**，要么是指向**静态区变量**的指针或引用！

        1. 必须是整型（bool，short, int, long 等）

            看一个double的例子：
                
                template <double x>
                void getX()
                {
                    cout << x << endl;
                }
                编译报错简直太长太长(模板编程的缺点)...但是第一个错误就是：
                'double' is not a valid type for a template non-type parameter
            
            其实实数本来作为模板参数意义也不大，而且实数因为在不同机器表示可能不同，因此在编译时是没法确定大小的？？(不对，sizeof就可以啊！！到底是什么原因？)

        2. 静态区变量的指针或引用

            首先必须是引用或指针；

            其次必须是静态区的变量——即全局变量，静态变量。

        一句话，必须编译时可以确定其值。

3. 大多数编译错误发生在实例化期间

    因为不实例化时编译器并不会生成代码。

4. 模板声明与定义需要在同一个文件内（头文件）

5. 尽量编写类型无关的代码

    即适用性更高，对传入类型依赖更小。

    比如几个可能的需求： 

    1. 使用 const & , 这样可以处理数组

    2. 只使用 `<`  (准确的说，使用 less<T>等即可)

6. 模板函数可通过编译器自动推导参数类型，而模板类则只能通过用户`在模板名<XXX>`中的`XXX`来指定模板参数. `XXX`称为显式模板实参。

7. 类模板的实例化

    如

        template <typename T>
        class ClassT
        { ... };

    使用`ClassT<int> t;`之后实例化的结果为:

        template <>
        class ClassT<int>
        { ... };

8. 模板类的成员函数只有当程序用到它时才会实例化。

    所以如过即使一个错误的、未使用的模板类成员函数存在，也不会报错。

9. 在模板类作用域内部可以省略模板实参

    这个与类作用域内不必使用类作用域限定符同理。

    当我们在类作用域外部定义类成员是，应当如此定义：

        template <typename T>
        ClassT<T> ClassT<T>::foo(ClassT &param)
        {
            ClassT newClass;
            ...
        }

    正如前面章节提过的，对签名 `ret-type func-name(param-list){ func-body }`, `ret-type`即`func-name`都是在作用域外部，故需要使用作用域限定符！因此使用`模板名+模板参数列表`， 从函数实参列表开始，都算作类作用域内部，可以不再使用模板实参而直接用模板名替代。

    当然，无论何时，使用完整的名字总是不会有问题的！

    不过，我们应该在表意清晰的情况下，尽可能简化我们的代码！

10. 模板类和友元

    模板类与模板类间以一相同实例的*1 VS 1*

        template <typename T>
        class ClassT<T>;

        template <typename T>
        class FriendT<T>
        {
            friend class ClassT<T>;
        };

    即用friend class 声明时使用同一模板参数T！因为这样定义的话，其实对`FriendT<T>`, 其友元类是确定的:`ClassT<T>` .

    模板类与模板类间**任意 VS 任意**

        template <typename T>
        class FriendT<T>
        {
            template <typename X>
            friend class ClassT;
        };

    这里一定要注意！任意对任意时，friend class前需要`template <typename X>`，此时模板变量应该与外层模板的模板变量不一致（外层是`T`）; 此外，`friend class ClassT;` **友元类后面一定不能加模板实参！**加了就会报错！最后，ClassT也不必再前面提前声明。

    我觉得这个地方太容易错了。

    最后，C++11增加了一个特性——可以令模板自己的类型为友元。即

        template <typename T>
        class ClassT
        {
            friend class T;
        };

    这说明，允许内置类型为友元类（语法上的允许，实际上没有任何用处...）。

11. 模板类型别名

    可以用`typedef`来重命名`实例化的模板`.

        typedef ClassT<int> ClassInt;

    C++11中，增加了使用`using` 来重命名模板.

        template <typename T>
        using AnotherName = ClassT<T>;

        template <typename T>
        using twins = pair<T, T>;
        template <typename T>
        using partNo = pair<T, unsigned>;

    可以看到这非常地灵活(有点相当于std::bind中功能)！同时，这也非常的直观。注意，该功能是`typedef`所不支持的。

    从这个角度说， 真的可以放弃 `typedef`.

12. 模板参数名的作用域

    模板参数名的可用范围是：参数名声明以后到模板声明或定义结束。

        // 1
        template <typename T, typename F=less<T>> int compare(const T &v1, const T &v2, 
                                                              F f=F());
        // 2
        template <typename T> class X
        {
            T t;
        };

    即是说，从声明这个名字开始，到同级一个表达式结束（只是想说，在模板类外部定义成员函数，需要在每个成员函数前写上template <XXX>）。

    另外，关于模板名字的覆盖：

    1. 模板名字可以覆盖前面的非模板名字

    2. 模板内部作用域下，不能再覆盖模板名字。

    两个实例：

        // 1. 模板名字可以覆盖前面的非模板名字 (这里外部名字是变量名，也可是typedef的类型名)
        int T = 10;
        template <typename T, typename F=less<T>>

        // 2. 模板内部作用域下，不能再覆盖模板名字。
        template <typename T, typename F=less<T>>
        int compare(const T &lhs, const T &rhs, F f = less<T>())
        {
            int T = 10;
            //...
        } -> 报错： error:  shadows template parm 'class T'

13. 模板名字不重要

    如书上的例子：

        template <typename T> T calc(const T&, const T&);
        template <typename U> U calc(const U&, const U&);
        template <typename Type>
        Type calc(const Type &lhs, const Type &rhs)
        {
            // ...
        }

    上述3个均是同一个函数模板签名。前两个是声明，后一个包含定义。

14. 使用类内成员（如果是类型一定要加`typename`）

    如果模板类型参数T，其有类内成员，如下的写法：

    `T::val` 

    表示`val`是类型`T`的类静态（公有）成员；如果要表示类内的一个类型，需要使用前缀关键字`typename`:

    `typename T::type XXX`.

15. 模板参数列表也可以使用默认参数！

    使用的方式和如前面的例子：

        template <typename T, typename F=less<T>>
    
    遵循的规则与函数形参中默认参数相同：默认参数之后要么全是默认参数，要么没有额外参数。

    最后，对于函数模板，如果全部有默认参数，那么调用时就可以省略模板实参（因为模板函数有自动类型推导过程！）；但是对模板类，即使全有默认值了，也需要一个空的尖括号表示实例化！

## 习题

1. typename 与 class 有什么不同，什么时候必须使用typename？

    如果是在模板参数列表中，那么二者毫无区别。

    但是如果表示模板类型的成员是类型（模板的类型成员），那么就必须使用typename;

2. inline与template

    首先，从语法上来说，如果要使用`template +  inline` , 需要把`inline`放在`template`之后。

        template <typename T>
        inline
        void F(const T& t)
        {
            // ...
        }

    不过，对于非全特化的模板，inline关键字从实际效果上来看似乎毫无作用的——与inline函数一样，必须保证声明定义在一个文件；是否内联，有编译器决定。（不能完全肯定！看了爆栈上的讨论，没有看太清楚，但是有一点比较直白：如果你觉得这个函数该内联，那么管他什么呢，写上inline就行！）



