---
layout: mathpage
title: C++Primer读书笔记16
date: 2016-08-04
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第十六章 - 模板与泛型编程。
---
> C++ Primer（第五版）第十六章 - 模板与泛型编程。

1. 泛型与OOP
    
    泛型与OOP都能处理在编写程序时不清楚具体类型的情况。

    OOP是通过继承+动态绑定；而泛型则是通过编写类型独立的代码，并且在编译时实例化模板完成。

2. 泛型编程的基础是模板。模板可以解释为一个创建类或函数的蓝图或公式。

3. 模板参数列表

    模板参数列表可以类比函数参数列表。函数参数（形参）在调用时初始化，而模板参数在实例化模板时显示或隐式指定。

    1. 通过`template<XXX>`来指定模板参数列表。模板参数列表在定义模板时必须不为空。

    2. 模板参数有两类，一类是`模板类型参数`，通过 `typename`或者`class`指定（二者完全等价，class是在typename没有出来前所使用的名称），通过此参数可以定义**类型**；另一类称为`非类型模板参数`，即通过`常规类型 + 名称`指定，定义的是值。

        综上，**模板参数列表可以定义类型、也可以定义值**。如下：

            template<typename T, size_t N>
            constexpr size_t size(const T (&a)[N])
            {
                return N;
            }
    3. 传递给模板参数列表中的值，要么是**整型字面值**，要么是指向**静态区变量**的指针或引用！

        1. 必须是整型（bool，short, int, long 等）

            看一个double的例子：
                
                template <double x>
                void getX()
                {
                    cout << x << endl;
                }
                编译报错简直太长太长(模板编程的缺点)...但是第一个错误就是：
                'double' is not a valid type for a template non-type parameter
            
            其实实数本来作为模板参数意义也不大，而且实数因为在不同机器表示可能不同，因此在编译时是没法确定大小的？？(不对，sizeof就可以啊！！到底是什么原因？)

        2. 静态区变量的指针或引用

            首先必须是引用或指针；

            其次必须是静态区的变量——即全局变量，静态变量。

        一句话，必须编译时可以确定其值。

3. 大多数编译错误发生在实例化期间

    因为不实例化时编译器并不会生成代码。

4. 模板声明与定义需要在同一个文件内（头文件）

5. 尽量编写类型无关的代码

    即适用性更高，对传入类型依赖更小。

    比如几个可能的需求： 

    1. 使用 const & , 这样可以处理数组

    2. 只使用 `<`  (准确的说，使用 less<T>等即可)



