---
layout: mathpage
title: C++Primer读书笔记5
date: 2016-03-21
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第八章 - IO类。
---
> C++ Primer（第五版）第八章-IO类读书笔记。

1. IO类

    | 头文件| 类名称 |
    |-------|-------|
    |iostream | istream , ostream , iostream |
    |fstream  | ifstream , ofstream , fstream |
    |sstream  | istringstream , ostringstream , stringstream|

        #include<sstream>

        stringstream s ; 
        s << 1 << "\n" << 2 ; // 输入到流中 
        cout << s << endl ;   // 其实只输出了地址
        cout << s.str() << endl ; // 输出了其中的内容
        int b ; 
        while(s >> b) cout << b << endl ; // 从流中读取

        结果：

        0xbfd0e838
        1
        2
        1
        2

    按照官方文档，stringstream 使用了stringbuf类。

2. IO类不可赋值和拷贝

    所以只能传递引用；

    同时，由于每次操作IO后IO类将会发生变化（内部指针、状态），所以一般不用const修饰。（不是不能，但是用const之后，既不能输入也不能输出，意义不大）

3. IO类的状态判断

    以下均在IO类的命名空间下。

    状态类型： iostate 

    状态取值： badbit , goodbit , failbit , eofbit

    状态函数： bad() , good() , fail() , eof() 

    当然建议使用状态函数来获得状态结果了，因为返回的就是true/false，而不是状态值；

    可以使用函数: rdstate() 来获得真实的状态值，即返回类型为iostate , 可以挨个与各状态取值判断：

        ios::iostate state = s.rdstate() ;
        cout << (state == ios::goodbit) << (state == ios::badbit) << (state == ios::failbit) 
             << (state == ios::eofbit) << endl ;

    但是根据测试结果，似乎这样判断的结果与通过状态函数的结果不一致。具体原因未深究。

    使用函数clear()来复位状态。

    以下代码：

        s << 1 << "\n" << 2 ; 

        int b ; 
        while(s >> b) cout << b << endl ;
        s.clear() ；
        cout << "----------" << endl ;
        while(s >> b) cout << b << endl ;

    即在上次已经输出完毕后，通过重置状态，使得其又可以从头开始读取！猜测clear还会清楚读取位置的指针！试试：

        s << 1 << "\n" << 2 ; 
        int b ; 
        s >> b ; 
        cout << b << endl ;
        s.clear() ;
        s >> b ; 
        cout << b << endl ;

    然而**结果令人失望**... 即，它只能清楚这几个标志位！不能重置读取位置的游标！所以，上面之所以可以重复读取，应该是因为到达EOF后，类内部自动将游标归0，同时置eofbit位。这样清除eofbit 后，又可以从头开始读了。


 