---
layout: mathpage
title: C++Primer读书笔记5
date: 2016-03-21
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第八章 - IO类。
---
> C++ Primer（第五版）第八章-IO类读书笔记。

1. IO类

    | 头文件 | 类名称 |
    |-------|-------|
    |iostream | istream , ostream , iostream |
    |fstream  | ifstream , ofstream , fstream |
    |sstream  | istringstream , ostringstream , stringstream|

    **继承关系**

    ```C++
                                <- istringstream
                                <- ifstream
                    <-  istream <- 
    ios_base <- ios  |            |- iostream <-| fstream
                    <-  ostream <-            <-| stringstream
                                <- ofstream
                                <- ostringstream                    

    ```

    ```C++

        #include<sstream>

        stringstream s ; 
        s << 1 << "\n" << 2 ; // 输入到流中 
        cout << s << endl ;   // 其实只输出了地址
        cout << s.str() << endl ; // 输出了其中的内容
        int b ; 
        while(s >> b) cout << b << endl ; // 从流中读取

        结果：

        0xbfd0e838
        1
        2
        1
        2

    ```

    按照官方文档，stringstream 使用了stringbuf类。


    **update**

    最近在工作中用了下stringstream , 来说说过程：

    需求：需要通过boost::archive::text_oarchive来序列化一个Model（CNN 库中的Model），这个序列化类需要一个文件流作为参数。



2. IO类不可赋值和拷贝

    所以只能传递引用；

    同时，由于每次操作IO后IO类将会发生变化（内部指针、状态），所以一般不用const修饰。（不是不能，但是用const之后，既不能输入也不能输出，意义不大）

3. IO类的状态判断

    以下均在IO类的命名空间下。

    状态类型： iostate 

    状态取值： badbit , goodbit , failbit , eofbit

    状态函数： bad() , good() , fail() , eof() 

    当然建议使用状态函数来获得状态结果了，因为返回的就是true/false，而不是状态值；

    可以使用函数: rdstate() 来获得真实的状态值，即返回类型为iostate , 可以挨个与各状态取值判断：

        ios::iostate state = s.rdstate() ;
        cout << (state == ios::goodbit) << (state == ios::badbit) << (state == ios::failbit) 
             << (state == ios::eofbit) << endl ;

    但是根据测试结果，似乎这样判断的结果与通过状态函数的结果不一致。具体原因未深究。

    使用函数clear()来复位状态。

    以下代码：

        s << 1 << "\n" << 2 ; 

        int b ; 
        while(s >> b) cout << b << endl ;
        s.clear() ；
        cout << "----------" << endl ;
        while(s >> b) cout << b << endl ;

    即在上次已经输出完毕后，通过重置状态，使得其又可以从头开始读取！猜测clear还会清楚读取位置的指针！试试：

        s << 1 << "\n" << 2 ; 
        int b ; 
        s >> b ; 
        cout << b << endl ;
        s.clear() ;
        s >> b ; 
        cout << b << endl ;

    然而**结果令人失望**... 即，它只能清除这几个标志位！不能重置读取位置的游标！所以，上面之所以可以重复读取，应该是因为到达EOF后，类内部自动将游标归0，同时置eofbit位。这样清除eofbit 后，又可以从头开始读了。


 4. 管理输出缓冲

    默认情况下，新建一个输出流，都会有缓冲。

    以下情况下会清空输出流缓冲：

    1. 程序正常结束——main函数中的return操作包含刷新缓冲操作

    2. 缓冲区满

    3. 使用操纵符 ： endl , ends , flush 

    4. 使用控制符 ： unibuf

    5. 如果该输出流关联到另外一个（多个）流，那么读、写（根据关联流的具体情况）关联的流，该输出流会先刷新缓冲

    需要解释下上面的情况：

    1. 关于操纵符：

        endl非常熟悉，在缓冲中加入换行符，并刷新；

        flush，直接刷新。

        ends，在缓冲中加入空字符（null ， 即`\0`），刷新。

            cout << "info" << endl 
                 << "info" << flush 
                 << "info" << ends ;
            ---------
            info$
            infoinfo^@

    2. 关于unibuf

            cout << unibuf ; // open
            ...
            cout << nounibuf ; // close

        cerr默认就是使用了unibuf控制符，这样关闭了缓冲，每次写都会直接输出。

    3. 关于官廉流

        使用`tie`来将流与输出流关连起来，有重载。

            cin.tie(cout) ; // 将cin与cout关连；
            cin.tie(nullptr) ; // 停止cin的关连

            cin.tie() ; // 重载；返回目前cin关连的流。
