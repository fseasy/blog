---
layout: mathpage
title: C++Primer读书笔记14
date: 2016-06-22
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第十四章 - 重载运算符与类型转换。
---
> C++ Primer（第五版）第十四章-重载运算符与类型转换。

> 前述： 不知不觉，竟然已经有3个月没有更新了。的确，自从开始看标准库后，因为书上内容实在太多，而且慢慢偏离了只记关键点的初衷，越来越求全、求多，导致笔记就这么一下子断了。而且一断就是三个月，零一天！决心每天记一点，只记关键！不管顺序。

1. 成员访问运算符`->`的重载，只需要返回需要访问的对象指针即可

    对，Primer上说，成员访问符`->`就是这么特殊，不管你怎么想重定义它，它永远都保留了访问成员的功能。

    所以，你必须返回一个指针，或者能够返回一个指针、重载了`->`的对象。

    后面一句有点绕，就说这个运算符可以递归的。但不管怎样，递归的最后一层，一定是一个指针。

    定义永远会很麻烦，自己实现时记得就好了。绝对返回一个指针，或者正确重载了`->`的对象。

2. lambda表示式就是一个匿名函数对象

    首先，什么是函数对象？　就是一个类，如果重载了函数调用运算符`()`，那么这个类的对象就称为函数对象。

    著名的`boost::program_options::options_description`中的`add_options()`函数返回的对象（应该就是本身）就是一个函数对象，所以可以神奇的一直用`()`来添加参数。第一眼看到后真是觉得仅为天人啊。

    后来看到标准库中的一些比较函数，如 `std::greater<T>`就是一个重载了`()`的类，所以传参时需要构建一个函数对象：

        vector<int> nums = {2,1,4,8,5} ;
        sort(nums.begin(), nums.end(), greater<int>())

    ok，函数对象的一个不一般的地方就是，首先，它是一个对象（类），它可以有成员变量！可以有构造函数！其次，就是具有函数的功能，可以被调用。而这些东西，不就是构成了lambda表达式所必须的条件吗！

    捕获的东西，不管是引用、还是值，都被作为匿名类的成员变量，并自动构建对应的构造函数，在构造的那一刻初始化。

    注意的是，lambda表达式的结果是一个匿名函数**对象**，而不是类。而重载`()`得到一个可以生成函数对象的类。

    类与对象，似乎不应该在这里提？没什么太大的意思了。
    


