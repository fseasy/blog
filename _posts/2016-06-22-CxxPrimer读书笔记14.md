---
layout: mathpage
title: C++Primer读书笔记14
date: 2016-06-22
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第十四章 - 重载运算符与类型转换。
---
> C++ Primer（第五版）第十四章-重载运算符与类型转换。

> 前述： 不知不觉，竟然已经有3个月没有更新了。的确，自从开始看标准库后，因为书上内容实在太多，而且慢慢偏离了只记关键点的初衷，越来越求全、求多，导致笔记就这么一下子断了。而且一断就是三个月，零一天！决心每天记一点，只记关键！不管顺序。

1. 成员访问运算符`->`的重载，只需要返回需要访问的对象指针即可

    对，Primer上说，成员访问符`->`就是这么特殊，不管你怎么想重定义它，它永远都保留了访问成员的功能。

    所以，你必须返回一个指针，或者能够返回一个指针、重载了`->`的对象。

    后面一句有点绕，就说这个运算符可以递归的。但不管怎样，递归的最后一层，一定是一个指针。

    定义永远会很麻烦，自己实现时记得就好了。绝对返回一个指针，或者正确重载了`->`的对象。

2. lambda表示式就是一个匿名函数对象

    首先，什么是函数对象？　就是一个类，如果重载了函数调用运算符`()`，那么这个类的对象就称为函数对象。

    著名的`boost::program_options::options_description`中的`add_options()`函数返回的对象（应该就是本身）就是一个函数对象，所以可以神奇的一直用`()`来添加参数。第一眼看到后真是觉得仅为天人啊。

    后来看到标准库中的一些比较函数，如 `std::greater<T>`就是一个重载了`()`的类，所以传参时需要构建一个函数对象：

        vector<int> nums = {2,1,4,8,5} ;
        sort(nums.begin(), nums.end(), greater<int>())

    ok，函数对象的一个不一般的地方就是，首先，它是一个对象（类），它可以有成员变量！可以有构造函数！其次，就是具有函数的功能，可以被调用。而这些东西，不就是构成了lambda表达式所必须的条件吗！

    捕获的东西，不管是引用、还是值，都被作为匿名类的成员变量，并自动构建对应的构造函数，在构造的那一刻初始化。

    注意的是，lambda表达式的结果是一个匿名函数**对象**，而不是类。而重载`()`得到一个可以生成函数对象的类。

    类与对象，似乎不应该在这里提？没什么太大的意思了。
    
3. 标准库中的函数对象

    标准库主要对
    
    算术(`+,-,*,/,%,-(取负)`)、
    
    关系(`==,!=,>,>=,<,<=`)、

    逻辑(`&&,||,!`)

    操作预定义了函数对象。

    这些对象都是模板类对象。

    最后，Primer提到——如果我们要为指针做排序，使用常规的`<`是不对的！其行为是未定义的。我们需要使用`less<Type>`函数对象来完成指针的排序。

    WHY？ 在[爆栈](http://stackoverflow.com/questions/7446743/sorting-vector-of-pointers)上找到了一段描述：
        
        "If two pointers p and q of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of p<q, p>q, p<=q, and p>=q are unspecified."

    经过多次阅读，大概就是说如果两个指向同类型的指针不是在同一数组中，或者应用于不同的函数(?)，或者其中有一个为空，那么两个指针的比较就是未定义的！不过使用`less`就OK...

    仍然没有具体的原因，不过的确更加清晰了。估计是多了更多的细致规则吧。

4. 标准库function对象为各种类型的、具有同样调用形式的可调用对象建立共同的绑定

    C++中可调用对象有——函数、函数指针、lambda表达式，函数对象，bind创建的对象。

    即使这些对象有相同的调用形式——即返回类型和参数形式，如 `int (int,int)`，仍然不能放在一起，用一个类型指向他们。（注：函数和函数指针二者倒是几乎完全等价的）。

    有时我们需要这样一个入口，使得其能够存储具有相同调用形式的所有可能的函数对象——比如做一个map，用来完成算术符字符串到函数调用的映射。

    C++11新标准中的`function`类型解决了此问题。

    其构建形式 `function<retType(args)> f = xxx ;`可以为具有相同调用形式的所有可调用对象提供统一的类型支持。

    此外，在上述map字符串到可调用对象的例子中，Primer还说了如何处理重载的情况：对于重载，其函数名称相同。而我们放入到map时，如果直接放函数名（函数指针），并不能根据map中映射的类型推断出所使用的重载函数中具体的哪个。此时，列举了两种解决办法： 1. 新建一个函数指针并用对应签名的重载函数赋值，此时是可以区分的（因为右边需要明确指明函数调用形式）； 2. 套上一层lambda调用，在lambda内部做重载函数调用。

    最后，对function对象（包括lambda对象），对象是对象，指针是指针——不要被函数与函数指针弄乱了。建议函数与函数指针也按照常规思路来使用。

5.  类的转换

    类型转换运算的操作：

        operator `Type`() const 
        {

        }

    其中的Type就是要转换到的其他类类型。该转换函数无返回值，因为其返回值必须是Type类型的对象。其次，const是可选的，建议加上，因为类型转换一般不会改变成员变量，而且我们也需要在const对象上做类型转换。