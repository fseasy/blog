---
layout: mathpage
title: 算法设计与分析-课后总结3
date: 2015-09-23
categories: 笔记
tags: 算法
onewords: 第三节课主要讲了分治算法相关的内容。
---
> 从第三节课后半段到第四节课，主要讲了分治算法。分治算法包含`分`,`治`,`合`三个过程。其中“分”与“合”一般是分治能够优化时间效率的关键。“治”一般是以分割的子问题作为输入递归调用算法。

###分治算法概述

分治算法一般包含3个步骤 ：

1. 分 (Divide)

    将大问题（按照某种条件）拆分为小问题。**[算法关键]**

    记时间复杂度为 $ T_{divide}(n) = D(n)$

2. 治 (Conquer)

    以子问题作为输入，递归调用算法，直到遇到`边界条件`。

    设分为$a$个子问题，每个子问题的规模为原规模的$\frac{1}{b}$ ， 记时间复杂度为$T_{conquer}(n) = aT(\frac{b}{n})$

3. 合 (Combine / Merge)

    对每个子问题合并结果。**[算法关键]**

    记时间复杂度为 $T_{merge}(n) = C(n)$

总时间复杂度为$T(n) = aT(\frac{n}{b}) + D(n) + C(n)$ 


###分治的例子

1. 在排序中的应用

    1. 归并排序 MERGE-SORT

        > 待完成代码后补充

    2. 快速排序 QUICK-SORT
        
        > 待完成代码后补充

2. 整数乘法

    问题描述：

    *输入* : 2个均为n位的二进制数X与Y

    *输出* : X与Y的乘积
    
    乘法的本质是转换到加法来做。
    
    两个n位二进制数相乘，直接做，需要做可以认为需要做两个$1 \to n$的循环，复杂度为$O(n^2)$

    使用分治方法，我们可以把n位的二进制数分为两半，分别运算，再合并。
    
    直观的分治策略：

    ![常规分治过程](/assets/img/class/algorithm/algorithm_3_1_num_mul.jpg)

    我们发现算法的复杂度并没有得到优化。我们可以尝试*优化分的过程*。

    优化的分治策略：

    ![优化分的过程](/assets/img/class/algorithm/algorithm_3_2_num_mul.jpg)
    
    比较神奇的方式~ 减少了乘法的数量，我们的复杂度递归方程变为： 

    $T(n) = 3T(\frac{n}{2}) + O(n)$ 

    使用Master定理，得到复杂度为$T(n) = O(n^(lg3)) = O(n^{1.59})$

3. 矩阵乘法

    类似上述整数乘法。

    *输入* : 两个$n \times n$的矩阵A , B 。
    
    *输出* : 矩阵乘法结果。

    矩阵乘法的过程：

        for i <- 1 , n 
            for j <- 1 , n
                $a_{ij} = \sum_{k=1}^{k=n}A_{ik}B_{kj}$ 

    易知其复杂度为$O(n^3)$

    分治法我们把每个矩阵都分为等大的四个矩阵。

    ![矩阵分割](/assets/img/class/algorithm/algorithm_3_3_matrix.jpg)

    根据矩阵乘法，有

    $C_{11} = A_{11} \times B_{11} + A_{12} \times B_{21}$

    $C_{12} = A_{11} \times B_{12} + A_{12} \times B_{22}$

    $C_{21} = A_{21} \times B_{11} + A_{22} \times B_{21}$

    $C_{22} = A_{21} \times B_{12} + A_{22} \times B_{22}$

    如果分治法直接按照上述方法做分割，那么递归方程为 $T(n) = 8T(n/2) + O(n^2)$ , 由Master定理，其复杂度为$T(n) = \Theta(o^3)$

    所以我们需要如上面的整数乘法一般，进行一些变换，来达到减少乘法运算（子问题）的目的。

    变换结果如下（真的不知道怎么弄出来的 = =）：
    
    ![矩阵乘法变换](/assets/img/class/algorithm/algorithm_3_4_matrix.jpg)

    ![矩阵乘法变换后合并](/assets/img/class/algorithm/algorithm_3_5_matrix.jpg)

    如此得到的结果：

    ![矩阵乘法结果](/assets/img/class/algorithm/algorithm_3_6_matrix.jpg)

    
