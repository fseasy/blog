---
layout: mathpage
title: C++Primer读书笔记3
date: 2015-12-15
categories: 技术 笔记 
tags: C++ 笔记 C++Primer
onewords: 第六章-函数。
---
> C++ Primer（第五版）第五章-函数读书笔记。

1. 函数调用过程

    函数使用`调用运算符`，即`$()$`来调用。

    调用是，第一步便是使用实参（arguments）去隐式初始化函数的形参(params)。形参中是每个参数，必须有类型，但可以没有变量名！（模板时可能只需要类型名）但不管有没有变量名，参数都要传递过去。

            void f(int , int * , int &) ; // 声明， 只需类型，不用加变量名

    `return`要执行两步，第一是用返回的值初始化接收值（如果有），其次跳回主调函数。当然，从汇编角度就更好理解了吧？

    > 是先弹栈，再压返回值？

2. 局部自动变量与局部静态变量

    局部变量，包括形参和函数内部定义的变量。 所以除了全局变量，就是局部变量了吧。

    局部静态变量，就是使用`static`关键字修饰的 。与之相对的，称为自动变量。
    
    静态变量虽然是局部的，但是却只会初始化一次，且与整个程序生命周期相同。库函数中的`strtok`函数，就使用了静态变量来记住上次分割的位置。

    书上的例子，记录调用次数：

        size_t count_calls()
        {
            static size_t ctf  = 0 ;
            return ++ctf ;
        }
    
    自动变量就是常见的普通变量了，“随控制路径”创建变量，超出作用域后就销毁。

    二者初始化也有区别——局部自动变量，如果不显式初始化，就会执行默认初始化。对内置类型的局部变量，就是随机初始化（或者说不被初始化，仅申请空间）。静态变量则会执行值初始化，即初始化为0 ；

    > 全局（自动）变量，也会执行值初始化，即初始化为0 .

3. 函数声明

    声明定义到头文件，定义（实现）在源文件。定义时需要引入头文件。头文件有必要加编译保护头。

    可声明多次，但只能定义一次。

4. 分离式编译

        cc -c including.cc # 生成including.o / including.obj
        cc -c main.cc # 生成 main.o / main.obj
        cc main.o including.o -o main # 生成main / main.exe

5. 参数传递

    记住，`实参到形参传递的过程` 等价于 `用实参初始化形参`

        void f(int param_a , const string & param_b) ;
        int argument_a = 2 ;
        f(argument_a , "ni hao a") ;

        <==>

        int param_a = argument_a ;
        const string & param_b = "ni hao a" ;

    最佳实践： 使用引用避免拷贝。

        void f(const string & str , const vector<int> & vec) ;

    注意： 形参中的顶层const将被忽略。

    > 顶层const是指： 1. cont int a ; 2. int * const p = &a ;

        故
        void f(const int a) ;
        与
        void f(int a)
        在编译器看来是一样的！所以，这样“定义”将报错！

    在形参中定义顶层const，保证了在函数中不能修改该形参！这与实参能否被修改是没有关系的！

6. 传引用、常量引用

    传递引用参数的好处：

    1. 避免拷贝

    2. 有时只能传递引用——IO类不支持拷贝（值传递）

    常量引用：

    如果函数不会改变参数的值，推荐传递常量引用。

        bool is_in_sentence(const string &str , char target_char) ;

    原因：

    1. 避免给调用者错觉。

    2. 定义为常量引用能够接受的参数更广。

        如果定义为普通引用，则 const对象 ， 字面值 ， 需要类型转换的对象 都不能够作为参数传递。

7. 数组形参

    数组两个性质：

    1. 不允许拷贝（赋值）

        即
            int a[2] = {1,2} ;
            int b[] = a ; // ERROR !

    2. 常常退化为指针

    上述两个性质决定了：*如果以传值方式定义数组形参，那么 数组就会退化为 指向数组头元素的指针*。

    所以，在以值传递形式定义数组形参时，等价于定义一个指针类型。

        void f(int a[]) ;
        void f(int *a) ;
        void f(int a[10]) ; 

    上述都是等价的。注意，尽管第三个尽管定义了数组维度，但是一点用都没有... 因为会被转换为指针！

    书上接着讲了在函数中如何获取数组的长度（知道数组结尾呢）？方法有3：

    1. 使用标识量

        即字符数组，使用'\0'作为字符数组的结尾。

    2. 传递头指针和尾指针

        可以使用begin和end函数。

            void print_array(int * array_beg , int * array_end) ;

    3. 传递数组长度

        这个在以前的C++中、以及C中最直观、常用

        言外之意，估计现在用begin、end方法更多吧。因为这样就保证了和迭代器的一致性接口了。的确更美观了。


    **引用方式传递的数组**

    例子：

        void f(int (&a)[10])

    一定要注意！

    1. 对数组的引用的写法： `int (&a)[10]` ， 如果写作`int &a[10]` 是非法的！因为此表示a是10个引用元素构成的数组——而我们知道，引用时不能构成数组的。我们定义的是对数组的引用！

    2. 数组的维度不可缺少。

        如果缺少，将报错：

            “错误：形参‘a’包含了指向具有未知边界数组‘int []’的引用”

        这是因为传递引用时，数组实参初始化形参时保证了数组未退化！

        所以要遵循数组引用的规则：

            int a[4] = {1,2,3,4} ;
            int (&b)[4] = a ;

        即要保证维度确定且一致！ 这个需要注意！！

    书上说，以后学习了模板，可以解决这个问题！就是可以传递不定长的数组。我想本质上，就是为相应的调用生成一个确切长度的函数吧。这也是模板干的事情嘛...所以本质是没有变的。


    关于数组的扩展

    感觉对数组一直没有搞懂。

    做了以下测试：

        int a[4] = {1,2,3,4}
        int b[] = a ;
        int b[4] = a ;

    第一个赋值语句报错：

    > 错误：数组必须为一个由花括号包围的初始值设定所初始化

    第二个赋值语句报两个错误：

    > 错误：初始值设定无法决定‘b’的大小

    > 错误：数组必须为一个由花括号包围的初始值设定所初始化

    由此得到结论，如编译器报错所言，数组是不能直接用数组赋值的！

    我们平时常用的是这样的：

        int *b = a ;

    所以常常造成了数组可以赋值的错觉。

    其实，上面真正的意义是——将数组a退化为指向数组第一个元素的指针，然后赋值给指针b。所以其本质是**指针的赋值**。

    **数组的退化**

    上面也提到了，如果我们使用值传递的方式传递数组参数，那么数组将会退化为指针。

    经过测试，我认为数组只能退化一次——即多维数组，只能是第一维发生退化。所以，在向函数传递多维数组时，只有第一维可以忽略维度大小，后面的都不能忽略——第一维退化为指针了，维度信息自然就损失了，所以编译器不能也不会检测；不过后面的维度都保持了数组的类型不退化，而数组是需要明确指定维度大小的，所以编译器要求必须指定维度。

    **数组与指针**

    上面说了数组的退化，这里就是要明确： 数组是数组，指针是指针。数组可以退化为指针，但是数组不是指针。

    **二维数组作为参数传递**

    考虑如下：

        void f(int **a) ;

    输入变量是指针的指针，它与普通二维数组没有关系！——可以认为，只有在C风格字符串数组时它才是有意义的。

        void f(char **a) ;

        char *a[] = {"str1" , "str2"} ;
        f(a) ; 

    因为一维数组退化为指针，变为指向数组首元素的指针，而首元素又是字符串数组，也是一个指针，所以满足char **的定义。而且，由于是硬编码字符串，且连续，所以内存中可以认为是连续的，可以在函数中使用 a[0] , a[1]来访问。如果我们我们将其他整型指针放到一个数组中，传递给函数时退化为一个int\*\*的变量， 但是不能使用a[0][0]来访问——这可能照成未知的结果！因为基于a的指针偏移，可能指向的不是其真正的内存空间！

    上面对应的等价定义就是：

        void f(int *a[]) ;

        void f(int **a) ;

    正确的二维数组传递方式，有两种：

        void f(int (*a)[10]) ; // (1)

        void f(int a[][10]) ; // (2)

    比较上面的定义与前面`int **`的差别，(1)中多了括号，表示其与变量是一个整体——a是指向一个int[10]类型的指针，即维度为10的整型数组的指针。(2)中指定了第二维的维度，因为第一维退化，其实其就(1)就是等价的。想想，还是(2)更加直观和好理解啊。（1）需要做数组向指针退化的逆向过程，即a值指向int[10]的指针，其实对应实参，其*可能*是int[10]的数组——数组的数组，就是二维数组咯。

    还有一种，就是对于二维数组，直接传递一个头元素指针即可。

        void f(int *a) ;
        int a[2][2] = {{1,2} , {3,4}} ;
        f(a) ;

    上述是可行的。我们要知道，多维数组在内存中，是一行一行按序依次存储的。所以，我们可以根据行列去访问它， 具体就是 a + row * col_size + col 。

    总结以上，有关数组的知识：

    1.  






    
    




    

