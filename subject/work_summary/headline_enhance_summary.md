---
layout: post
title: 低资源摘要生成
date: 2023-05-17
categories: 技术
tags: 工作总结
---

## 2023 年回忆

摘要生成主要2个挑战：

1. 如何找到文章的核心信息
2. 如何生成流畅通顺的话

借用预训练模型，可以让生成通顺的话变得容易；但是找到核心的信息，特别是符合特定要求的核心信息还是一个挑战。

要解决这个，一般都是标数据。但生成式摘要标注成本比较高，所以如何用少量标注就可以提升模型对关键信息的捕获，这是一个值得研究的点。

我们的思路比较直接：摘要数据比较难标，但是标题数据一般天然存在，也比较容易获取较大的量。能不能让标题数据来辅助摘要模型获取关键信息？基于这个信息我们再少量标注一些目标摘要数据，就能得到一个相对好的效果？这就是我们的 motivation.

这个 motivation 是偏直观的，还需要有数据支撑。 我们就找了一批同时有标题和摘要的数据，然后数据层面确认标题确实对摘要有用。

细节：选的是 Newsroom 这个数据，同时有标题、摘要、正文。
对比了一些方法：a. random-3; b. lead-3 c. headline d. headline-recall-正文sentence 获得的摘要的 ROUGE 值。
结论是 random3 < headline < headline-recall-正文sentence < lead-3.
其中 random3 < headine 和 headline-recall-正文sentence, 说明 headline 有价值；

1. 标题作为 predict 摘要，和 gold 摘要的 ROUGE 值；基于与标题字面近似选出来的句子作为 predict 摘要，和 gold 摘要的 ROUGE 值. 统计证明标题确实是有信息量的，但因为标题本身短，ROUGE 不占优；找句子出来效果更高 
2. 我们又看了下找出来的句子是不是都是 lead3 的。结果发现的 1/4 完全一样，2/4 部分一样，1/4 完全不同，说明标题相比 lead3 能够是有额外增益的。

这其实可以看做是一个远监督任务，让标题数据监督摘要对关键信息的识别和提取；

然后就是咋做了。

直接的做法就是先在标题数据上预训练，再拿预训练后的数据在摘要数据上微调；效果TODO；
另外因为现在已经有大模型了，而且 大模型预训练 + 领域预训练 + 任务微调也是比较work的范式，所以我们也试了这个方法，具体就是在 BART 模型上，用标题数据训练一下（因为本身就是 seq2seq 的框架，所以这个训练我们就直接做teacher-forcing的训练）；再用摘要数据微调；效果TODO；

因为这个项目我们主要还是想发论文，而上面的方法没啥新意，所以我们得想想其中存在的问题，然后针对性的去想一些解决方案。

## 2020 年交接内容

### 工作概述

本工作思路非常简单，就是尝试利用标题中蕴含的“文本关键信息”辅助摘要任务，难点是如何避免标题与摘要存在的差异：（1）标题与摘要的覆盖面不同，受长度限定，标题可能比摘要覆盖的信息少（2）语言模型的不同（对Abs decoder有影响）。
为此，我们想到了2种思路：

（1）采用预训练范式，按照DAE的思想，假设在Encoder侧mask掉输入文章的重要句子并在Decoder侧恢复，可以让模型学习对重要信息的关注。我们利用标题信息，计算正文中的重要句子，然后做DAE训练。具体 见 实验设定中的exp4，以及 中文论文的初稿 论文思路 ；   该方法在之前的实验中看来效果并不突出；而且，MASK掉重要句子再重构的想法，在 PEGASUS 中已经做了。

（2）通过loss来传递标题蕴含的“输入重要信息”，同时loss尽可能避免标题与摘要的差异。参见 论文思路2，我们用 Encoder侧的 SentenceSalience-hinge-loss来传递标题的“重要信息”，避免对decoder的影响，同时采用hinge loss的方法，减少因标题重要信息覆盖不足对文中所有句子的重要性评估有偏的负面影响。在Decoder侧，我们又用 SalienceRecall-reward 来让decoder生成包含重要信息的结果，甚至想用Generation-Style这个loss让模型区分标题与摘要的不同；最后用 摘要数据的 CE loss来让 Encoder更精确建模重要性，Decoder建模好语言模型。 我认为这个思路是自然的，但是它可能显得杂乱、创新性有限了。因为重点不在预训练，所以我们把问题设定为： low-resource + 通用预训练，利用标题数据进一步提升效果。

思路之上，实验做得不太顺利。我们换了3个codebase，同时对codebase的问题做了大量的与本工作无关的改进，这实在浪费时间，并且对实验推进产生了负面影响。具体的，随3个codebase更换的实验过程大致如下：

a. Paddle UniLM-qg 代码，其实只有代码 + ERNIE，改进了fp16的实现，重写infe
rence（支持cache，length-penalty, trigram-blocking），针对摘要任务改动输入处理；我们设置baseline是 UniLM + CNNDM, 期望在当前配置下效果对齐到官方UniLM + CNNDM的效果。然而事实是差距巨大（ROUGE1大概2个点）。随后折腾了很久，对自己的一些inference实现做检查、调整，输入做调整，始终没法提高，无奈放弃。

b. PyTorch presumm (BertSum), 可以直接跑，非常好；但后面遇到了2个问题： a. 会hang 2. 无法复现论文结果 （见 github上提的issue https://github.com/nlpyang/PreSumm/issues/135 ）； 通过对代码分析，觉得hang是因为多机数据读取负载不一致，可能某台机器读完了，而其他机器还在读，这样NCCL同步就会持续hang住，表现就是GPU利用率一直100%，但温度、功率又非常低。改动代码，解决此问题，同时让它支持100%断点续跑结果可复现，以及支持apex fp16； 完成了思路1的实验，效果不理想，使用预训练并没有提升…… 这个时候开始考虑 low-resource 这个设定，同时不再强调自己预训练，而是期望站在通用预训练的基础上来进一步提升。BertSum并不是通用生成预训练模型，继续基于这个模型做有些别扭（用了预训练，但又不是通用的生成预训练），只得放弃。

c. PyTorch BART (fairseq) 。BART是SOTA级别的通用预训练，同时复现BART在CNNDM上的效果成功，因此将其选为codebase. 整个仓库非常庞大，导致改动初期比较费力，但好在设计非常好，增添逻辑比较方便。完成了思路（2）中的部分想法，暂时依然没有好的效果——通用预训练太强了，标题的作用（特别是我们当前使用的newsroom数据）或许真的作用有限？

### 当前已有结论

（1）统计说明标题与摘要的异同： 以newsroom数据为例，定量说明标题与摘要间的异同

（2）基于思路1的已有实验结果（见 前瞻 - 利用标题提升摘要信息性 中的 "全量CNNDM实验效果" ）下的结论：在BertSumAbs 设置下， 通过MASK pretrain能够带来效果的轻微提升（约0.1），但假设（mask由标题指示的重要性句子帮助模型识别重要信息）不成立；此外，直接用标题数据作seq2seq的输入来“预训练”网络，同样能够得到与MASK pretrain近似的效果；这或许说明大规模数据是有效的，但“标题”可能作用不显著。

（3）low-resource 的已有实验结果： 5% CNNDM 下效果，目前还没有正向结论。
